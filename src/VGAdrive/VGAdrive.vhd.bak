--library ieee;
--
--use ieee.std_logic_1164.all;
--use ieee.numeric_std.all ;
--
--entity vga is port(
--	clk, reset: in std-logic;
--	hsync, vsync : out std-logic;
--	video-on, p-tick: out std-logic;
--	pixel-x, pixel-y: out std-logic-vector (9 downto 0)
--	);	
--end vga;
--
--architecture arch of vga is	
--	-- VGA 640-by-480 sync parameters
--	constant HD: integer :=640; -- horizontal display area
--	constant HF: integer:=16 ; --h.front porch
--	constant HB: integer:=48 ; --h.back porch
--	constant HR: integer:=96 ; --h. retrace
--	constant VD : integer :=480; -- vertical display area
--	constant VF : integer:= 10; -- v.front porch
--	constant VB: integer :=33; -- v.back porch
--	constant VR : integer :=2; -- v.retrace
--	
--	-- mod-2 c o u n t e r
--	signal mod2_reg, mod2-next : std-logic;
--	
--	-- sync counters
--	signal v-count-reg, v-count-next : unsigned(9 downto 0);
--	signal h-count-reg, h-count-next : unsigned (9 downto 0 );
--	
--	-- output buffer
--	signal v-sync-reg, h-sync-reg : std-logic;
--	signal v-sync-next , h-sync-next : std-logic;
--	
--	--status signal
--	signal h-end, v-end, pixel-tick: std-logic;
--	
--	begin
--	-- registers
--		process (clk, reset)
--		begin
--			if reset=’l’ then
--				mod2_reg <= ’0’;
--				v_count_reg <= ( others => ’O’ );
--				h_count_reg <= ( others => ’O’ );
--				v-sync-reg <= ’0’;
--				h-sync-reg <= ’0’;
--			elsif (rising_edge(clk)) then
--				mod2_reg <= mod2_next;
--				v_count_reg <= v_count_next;
--				h_count_reg <= h_count_next;
--				v_sync_reg <= v_sync_next ;
--				h_sync_reg <= h_sync_next ;
--			end if;
--		end process;
--	
--	-- mod-2 circuit to generate 25 MHz enable tick
--	mod2_next <= not mod2_reg;
--	-- 2 5 MHz pixel tick
--	pixel-tick <= ’1’ when mod2_reg=’l’ else ’0’;
--	-- status
--	h_end <= -- end of horizontal counter
--		’1’ when h_count_reg = (HD+HF+HB+HR-l) else --799
--		’0’;
--	v_end <= -- end of vertical counter
--		’1’ when v_count_reg = (VD+VF+VB+VR-l) else --524
--		’0’;
--		
--	-- mod-800 horizontal sync counter
--	process (h_count_reg, h_end, pixel_tick)
--	begin
--			if pixel_tick = ’l’ then -- 25 MHz tick
--				if h_end = ’l’ then
--				h_count_next <= ( others => ’0’ );
--			else
--				h_count_next <= h_count_reg + 1 ;
--			end if;
--		else 
--				h_count_next <= h_count_reg;
--		end if;
--	end process;
--	
--	-- mod-525 vertical sync counter
--	process (v_count_reg, h_end, v_end, pixel_tick)
--	begin
--			if pixel_tick = ’l’ and h_end = ’l’ then
--				if (v_end=’l’) then
--				v_count_next <= ( others => ’O’ );
--			else	
--				v_count_next <= v_count_reg + 1;
--			end if;
--		else
--		v_count_next <= v_count_reg;
--		end if;
--	end process;
--	
--	-- horizontal and vertical sync, buffered to avoid glitch
--	
--	h-sync-next <=
--		’1’ when (h_count_reg >= (HD+HF)) --656
--			  and (h_count_reg <= (HD+HF+HR-l)) else --751
--		’0’;
--	v-sync-next <=
--		’1’ when (v_count_reg >= ( VD+VF )) --490
--			  and (v_count_reg <= (VD+VF+VR-l)) else --491
--		’0’;
--	
--	-- video on / off
--	
--	video_on <=
--		’1’ when (h_count_reg < HD) and (v_count_reg < VD) else
--		’0’;
--		
--	-- output signal
--	hsync <= h_sync_reg;
--	vsync <= v_sync_reg;
--	pixel_x <= std_logic_vector(h_count_reg);
--	pixel_y <= std_logic_vector(v_count_reg) ;
--	p_tick <= pixel_tick;
--end arch;






































Library IEEE;
use IEEE.STD_Logic_1164.all;
use ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;

entity VGAdrive is
  port( clock            : in std_logic;  -- 25.175 Mhz clock
        red, green, blue : in std_logic;  -- input values for RGB signals
        row, column : out std_logic_vector(9 downto 0); -- for current pixel
        Rout, Gout, Bout, H, V : out std_logic); -- VGA drive signals
  -- The signals Rout, Gout, Bout, H and V are output to the monitor.
  -- The row and column outputs are used to know when to assert red,
  -- green and blue to color the current pixel.  For VGA, the column
  -- values that are valid are from 0 to 639, all other values should
  -- be ignored.  The row values that are valid are from 0 to 479 and
  -- again, all other values are ignored.  To turn on a pixel on the
  -- VGA monitor, some combination of red, green and blue should be
  -- asserted before the rising edge of the clock.  Objects which are
  -- displayed on the monitor, assert their combination of red, green and
  -- blue when they detect the row and column values are within their
  -- range.  For multiple objects sharing a screen, they must be combined
  -- using logic to create single red, green, and blue signals.
end;

architecture behaviour1 of VGAdrive is
  -- names are referenced from Altera University Program Design
  -- Laboratory Package  November 1997, ver. 1.1  User Guide Supplement
  -- clock period = 39.72 ns; the constants are integer multiples of the
  -- clock frequency and are close but not exact
  -- row counter will go from 0 to 524; column counter from 0 to 799
  subtype counter is std_logic_vector(9 downto 0);
  constant B : natural := 93;  -- horizontal blank: 3.77 us
  constant C : natural := 45;  -- front guard: 1.89 us
  constant D : natural := 640; -- horizontal columns: 25.17 us
  constant E : natural := 22;  -- rear guard: 0.94 us
  constant A : natural := B + C + D + E;  -- one horizontal sync cycle: 31.77 us
  constant P : natural := 2;   -- vertical blank: 64 us
  constant Q : natural := 32;  -- front guard: 1.02 ms
  constant R : natural := 480; -- vertical rows: 15.25 ms
  constant S : natural := 11;  -- rear guard: 0.35 ms
  constant O : natural := P + Q + R + S;  -- one vertical sync cycle: 16.6 ms
   
begin

  Rout <= red;
  Gout <= green;
  Bout <= blue;

  process
    variable vertical, horizontal : counter;  -- define counters
  begin
    wait until clock = '1';

  -- increment counters
      if  horizontal < A - 1  then
        horizontal := horizontal + 1;
      else
        horizontal := (others => '0');

        if  vertical < O - 1  then -- less than oh
          vertical := vertical + 1;
        else
          vertical := (others => '0');       -- is set to zero
        end if;
      end if;

  -- define H pulse
      if  horizontal >= (D + E)  and  horizontal < (D + E + B)  then
        H <= '0';
      else
        H <= '1';
      end if;

  -- define V pulse
      if  vertical >= (R + S)  and  vertical < (R + S + P)  then
        V <= '0';
      else
        V <= '1';
      end if;

    -- mapping of the variable to the signals
     -- negative signs are because the conversion bits are reversed
    row <= vertical;
    column <= horizontal;

  end process;

end architecture;


-- RGB VGA test pattern  Rob Chapman  Mar 9, 1998

 -- This file uses the VGA driver and creates 3 squares on the screen which
 -- show all the available colors from mixing red, green and blue

Library IEEE;
use IEEE.STD_Logic_1164.all;
use ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;

entity vgatest is
  port(clock         : in std_logic;
       R, G, B, H, V : out std_logic);
end entity;

architecture test of vgatest is

  component vgadrive is
    port( clock          : in std_logic;  -- 25.175 Mhz clock
        red, green, blue : in std_logic;  -- input values for RGB signals
        row, column      : out std_logic_vector(9 downto 0); -- for current pixel
        Rout, Gout, Bout, H, V : out std_logic); -- VGA drive signals
  end component;
  
  signal row, column : std_logic_vector(9 downto 0);
  signal red, green, blue : std_logic;

begin

  -- for debugging: to view the bit order
  VGA : component vgadrive
    port map ( clock => clock, red => red, green => green, blue => blue,
               row => row, column => column,
               Rout => R, Gout => G, Bout => B, H => H, V => V);
 
  -- red square from 0,0 to 360, 350
  -- green square from 0,250 to 360, 640
  -- blue square from 120,150 to 480,500
  RGB : process(row, column)
  begin
    -- wait until clock = '1';
    
    if  row < 360 and column < 350  then
      red <= '1';
    else
      red <= '0';
    end if;
    
    if  row < 360 and column > 250 and column < 640  then
      green <= '1';
    else
      green <= '0';
    end if;
    
    if  row > 120 and row < 480 and column > 150 and column < 500  then
      blue <= '1';
    else
      blue <= '0';
    end if;

  end process;

end architecture;