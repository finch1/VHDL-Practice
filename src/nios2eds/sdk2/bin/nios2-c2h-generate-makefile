#!/bin/sh
perl "-I$QUARTUS_ROOTDIR/sopc_builder/bin" "-I$QUARTUS_ROOTDIR/sopc_builder/bin/europa" - "$@" <<\ENDOFPERL
#!perl

my $usage_string = << 'END_OF_USAGE_STRING';

Usage: nios2-c2h-generate-makefile --sopc=<sopc> [<options>]

Description: Creates a C2H makefile fragment that specifies all
accelerators and accelerator options for the given application.

IMPORTANT:
You MUST use the --c2h flag when calling nios2-app-generate-makefile
in order to make your application with C2H.  This flag causes the
static C2H make rules to be included in your application makefile.
These rules in turn include the c2h.mk fragment generated by this
command. 

Note:
This command does not append accelerator info to the existing c2h.mk.
It creates a new c2h.mk each time it is called, overwriting the
existing. 

Required Arguments:

--sopc:                       The path to the system .sopc file.

Optional Arguments:

--app-dir:                   Directory to place the application
                             Makefile and ELF. If omitted, it defaults
                             to the current directory. 

--accelerator:               Specifies a function to be accelerated.
                             This argument accepts up to four
                             comma-separated values: 
                             (1) Target function name
                             (2) Target function file
                             (3) Link hardware accelerator instead of
                                 original software. 1 or 0.  Defaults
                                 to 1. 
                             (4) Flush data cache before each call.  
                                 1 or 0.  Defaults to 1.
                             Example:
                             --accelerator=foo,../../foo.c,1,0
                             --accelerator=bar,../../bar.c

--enable_quartus:            Building the app compiles the associated
                             Quartus II project.  Defaults to 0.

--analyze_only:              Disables hardware generation, SOPC
                             Builder system generation, and Quartus II
                             compilation for all accelerators in the
                             app.  Building the project with this
                             option only causes the report files to be
                             updated.  Defaults to 0.

--use_existing_accelerators: Disables all hardware generation steps.
                             The build behaves as if c2h.mk did not
                             exist, with the exception of possible
                             accelerator linking as specified in the
                             3rd option of each accelerator argument
                             (see above).  Defaults to 0.
    
Example:
  nios2-c2h-generate-makefile
    --sopc=../../std_1s40.sopc
    --app_dir=./
    --accelerator=foo,foo.c
    --accelerator=bar,../../../bar.c,1,0
    --use_existing_accelerators

---------------------------------------------------------------------

END_OF_USAGE_STRING
#
#####################################################################

use e_ptf;
use strict;

# parse_args: adapted from
# format_conversion_utils.pl::fcu_parse_args.
#
# The only change is that multiple arguments with the same key are
# appended to an array that is returned in the args hash.
# -------------------------------------
# fcu_parse_args
#
# Given a list of arguments, return
# a hash where the keys and values
# are taken from those arguments of
# the form "--key=value". The hyphens
# disappear from the key name.
#
# A command line switch of "--key"
# is equivalent to "--key=1".
#
# a special key named _argc contains
# a count of non-dash-dash arguments,
# and they are in the hash as {0}, {1},
# and so on.

sub parse_args
{
   my $valid_arg_keys = shift;
   my $arg;
   my $argVal;
   my $argc;
   my %hash;

   $argc = 0;

   unless (scalar @_)
{
      &print_usage_and_exit();
}


   while($arg = shift)
{
      if($arg =~ /^-+/)
{
         if($arg =~ /^-+(.*?)\=(.*)$/)
{
            $arg = $1;
            $argVal = $2;
}
         elsif($arg =~ /^-+(.*)$/)
{
            $arg = $1;
            $argVal = 1;
}

         my $current_value = $hash{$arg};
         if ($current_value ne '')
{
            if (ref($current_value) eq 'ARRAY')
{
               my @new_array = @$current_value;
               push (@new_array, $argVal);
               $argVal = \@new_array;
}
            else
{
               $argVal = [$current_value, $argVal];
}
}

         $hash{$arg} = $argVal;
}
      else
{
         $hash{$argc++} = $arg;
}

      unless ( grep {$arg eq $_} @$valid_arg_keys)
{
         print "\nBad argument: $arg\n";
         &print_usage_and_exit();
}
}
   
   $hash{_argc} = $argc;

   return %hash;
}

sub print_usage_and_exit
{
   print $usage_string;
   exit(1);
}

sub handle_args
{
   my @required_arg_keys = ();
   my @optional_arg_keys = ('ptf',
                            'sopc',
	                    'app_dir',
                            'accelerator',
                            'enable_quartus',
                            'analyze_only',
                            'use_existing_accelerators',
	                    'help',
                            'extended-help',
	                    'extended_help');

   my @valid_arg_keys    = (@required_arg_keys,
                            @optional_arg_keys);
   my %args = &parse_args(\@valid_arg_keys, @_);
   my $non_dash_dash_args = $args{_argc};

   if ($args{'help'} ||
       $args{'extended-help'} ||
       $args{'extended_help'})
{
      &print_usage_and_exit();
}

   if ($args{'sopc'})
{
      my $ptf = $args{'sopc'};
      $ptf =~ s/sopc$/ptf/;
      $args{'ptf'} = $ptf;
}
   elsif ($args{'ptf'} eq '')
{
      die "*** ERROR: System .sopc file not specified ***\n";
}

   foreach my $required_key (@required_arg_keys)
{
      if ($args{$required_key} eq '')
{
         die "*** ERROR: Null value for required argument $required_key ***\n";
}
}

   return %args;
}

sub eval_boolean_arg
{
   my $arg     = shift;
   my $default = shift;

   my $result = $default;

   if ($arg =~ /^(0|false|off|no)/i)
{
      $result = 0;
}
   elsif ($arg ne '')
{
      $result = 1;
}

   return $result;
}

sub validate_and_split_accelerator_list
{
   my $args = shift;
   my @list;

   return undef unless ($args);

   if (ref($args) ne 'ARRAY')
{
      $args = [$args];
}

   foreach my $a (@$args)
{
      my @terms = split(/,/, $a);
      if ((scalar(@terms)>4) | (scalar(@terms)<2))
{
         die "Improper number of comma-separated terms in accelerator argument: --accelerator=$a";
}
      
      my $name   = shift @terms;
      my $file   = shift @terms;
      my $enable = &eval_boolean_arg(shift @terms, 1);
      my $flush  = &eval_boolean_arg(shift @terms, 1);

      push (@list, 
{name   => $name,
             file   => $file,
             enable => $enable,
             flush  => $flush});
}

   return \@list;
}

sub organize_accelerators_by_file
{
   my $list = shift;

   my %files;

   foreach my $accel_hash (@$list)
{
      my $name   = $accel_hash->{name};
      my $file   = $accel_hash->{file};
      my $enable = $accel_hash->{enable};
      my $flush  = $accel_hash->{flush};

      my $file_hash = $files{$file} = $files{$file} || 
{functions => [],
       enabled   => [],
       flushed   => []};
      push (@{$file_hash->{functions}}, $name);
      if ($enable)
{
         push (@{$file_hash->{enabled}}, $name);
}
      if ($flush)
{
         push (@{$file_hash->{flushed}}, $name);
}
}

   return \%files;
}

sub convert_to_true_false_string
{
   my $var = shift;
   return ($var) ? 'TRUE' : 'FALSE';
}

sub generate_c2h_mk
{
   my ($files,
       $ptf_file,
       $app_dir,
       $enable_quartus,
       $analyze_only,
       $use_existing,
       $argv) = @_;

   $enable_quartus = &convert_to_true_false_string($enable_quartus);
   $analyze_only   = &convert_to_true_false_string($analyze_only);
   $use_existing   = &convert_to_true_false_string($use_existing);
   
   my $source_files = join (' ', keys(%$files));
   my $timestring = scalar (localtime);
   my $args = join("\n#    ", @$argv);
   my $filestring = << "END_OF_GLOBAL_STRING";
# c2h.mk
#
# Generated by nios2-c2h-generate-makefile
# $timestring
#
# Original command:
# nios2-c2h-generate-makefile
#    $args

PTF := $ptf_file

C2H_QUARTUS_COMPILATION = $enable_quartus
FORCE_C2H_RECOMPILE = TRUE
C2H_REPORT_ONLY = $analyze_only
C2H_NO_GENERATE = $use_existing

# Target CPU name for use by chac-generate
C2H_TARGET_CPU = \$\(CPU_NAME\)

APP_DIR := $app_dir
APP_CONFIG := .
OBJ_DIR := \$\(OBJ_ROOT_DIR\)
PROJECT := \$\(basename \$\(ELF\)\)

C2H_SRC = $source_files

END_OF_GLOBAL_STRING

   while (my ($filename, $filehash) = each %$files)
{
      my $functions = join(' ', @{$filehash->{functions}});
      my $enabled   = join(' ', @{$filehash->{enabled}});
      my $flushed   = join(' ', @{$filehash->{flushed}});

# I have *no idea* why the IDE plugin does this...
# but it does.
# So I'm doing it to be consistent.
      my $filename_without_extension = $filename;
      $filename_without_extension =~ s/(.*)\..*?$/$1/;

      my $file_section = << "END_OF_FILE_STRING";
# Accelerated functions in file: $filename
${filename_without_extension}_AC=${filename_without_extension}
\$\(${filename_without_extension}_AC\)_C2H_ACCELERATORS = $functions
${filename_without_extension}_EN=${filename_without_extension}
\$\(${filename_without_extension}_EN\)_C2H_ENABLED_ACCELERATORS = $enabled
${filename_without_extension}_FL=${filename_without_extension}
\$\(${filename_without_extension}_FL\)_C2H_DCACHE_FLUSH = $flushed

END_OF_FILE_STRING

      $filestring .= $file_section;
}

   return $filestring;
}

sub main
{
   my %args = &handle_args(@_);

   my $ptf_file            = $args{ptf};
   my $app_dir             = $args{app_dir} || './';
   my $accelerators        = $args{accelerator};
   my $enable_quartus      = &eval_boolean_arg($args{enable_quartus}, 0);
   my $analyze_only        = &eval_boolean_arg($args{analyze_only}, 0);
   my $use_existing        = &eval_boolean_arg($args{use_existing_accelerators}, 0);

   my $accelerator_list = &validate_and_split_accelerator_list($accelerators);
   my $files = &organize_accelerators_by_file($accelerator_list);
   my $c2h_mk_filestring = &generate_c2h_mk($files,
                                            $ptf_file,
                                            $app_dir,
                                            $enable_quartus,
                                            $analyze_only,
                                            $use_existing,
                                            \@_);

   my $outfile_name = $app_dir . '/c2h.mk';
   print "Writing $outfile_name\n";
   open OUTFILE, ">$outfile_name"
       || die "Unable to open $outfile_name for writing";
   print OUTFILE $c2h_mk_filestring;
   close OUTFILE;

   return 0;
}


### EXECUTION BEGINS HERE ###

my $main_result = &main(@ARGV);
exit($main_result);

### EXECUTION ENDS HERE ###
