#!/bin/bash

# add library path to both sopc builder AND nios2 kit
PERL5LIB=`cygpath -u "$QUARTUS_ROOTDIR/sopc_builder/bin"`:$PERL5LIB
PERL5LIB=`cygpath -u "$SOPC_KIT_NIOS2/bin"`:$PERL5LIB
export PERL5LIB

# wrap nios2-debug with correct tcl/tk libs
export TCL_LIBRARY=`cygpath -u "$SOPC_KIT_NIOS2/bin/nios2-gnutools/share/tcl8.4"`
export TK_LIBRARY=`cygpath -u "$SOPC_KIT_NIOS2/bin/nios2-gnutools/share/tk8.4"`

perl - `dirname "$0"` "$@" <<\ENDOFPERL
#!perl

use strict;
use format_conversion_utils;  # command parsing and sdk-settings-getter



# -------------------------------
# nios2-debug
# usage: nios2-debug foo.elf   <- launches the GDB/Insight and loads foo.elf
#        nios2-debug foo.srec  <- ditto



# ----------------------
# Globals

my $my_name = "nios2-debug";
my $my_debugger = "nios2-elf-insight";



# +------------------------------
# | r_system
# |
# | just like the built-in perl "system" call,
# | but we get a chance here to print it, log it,
# | whatever

sub r_system
    {
    fcu_print_command(@_);
    return system(@_);
    }



# +----------------------------------------
# | generate_gdb_cmd_file_contents( $filename, $elf_filename, $tcp_port, @lib_source_paths )
# |
# |  return a string that contains the contents to go in a GDB command file
# |  for use when launching GDB over JTAG
# |

sub generate_gdb_cmd_file_contents($$$@)
{
    my ( $filename, $elf_filename, $tcp_port, @lib_source_paths ) = @_;

    my $date_time = fcu_date_time();

    my $contents = <<EOT;
# $filename - a script used to launch $my_debugger
# Created by $my_name on $date_time
    
    file $elf_filename
    target remote localHost:$tcp_port
    load $elf_filename
    break *main
    jump *_start
EOT

    my $dir;
    foreach $dir ( @lib_source_paths )
    {
        $contents .= "    dir $dir\n";
    }

    return $contents;
}



# +---------------------------------------------
# | main()
# |

sub main
{
    my $dir_name = shift;   # first argument from shell-escaper up there is our own dir
                                                    # used to find the FS2/bin/ directory in which to put the user.tcl file we'll create
    $dir_name =~ s/\n//;    # remove trailing cr/lf
    $dir_name =~ s/\r//;    # remove trailing cr/lf
    $dir_name =~ s|\\|/|g;  # Bad slashes become good slashes.

    #
    # check arguments
    #

    my %args_hash = fcu_parse_args(@_);
    my $args_ref = \%args_hash;

    usage() if fcu_get_switch($args_ref,"help");
    usage() if fcu_get_switch($args_ref,"h");
    usage() if !fcu_get_switch($args_ref,"_argc");

    my $arg_cli = fcu_get_switch( $args_ref, "console" );
    unless ( $arg_cli )
    {
        $arg_cli = fcu_get_switch( $args_ref, "c" );
    }

    my $arg_reset = fcu_get_switch( $args_ref, "reset-target" );
    unless ( $arg_reset )
    {
        $arg_reset = fcu_get_switch( $args_ref, "r" );
    }

    my $arg_tcpport = fcu_get_switch( $args_ref, "tcpport", 2342 ); # TODO - use nios2-gdb-server --tcpport=auto option

    my $arg_cable = fcu_get_switch( $args_ref, "cable" );
    my $arg_device = fcu_get_switch( $args_ref, "device" );
    my $arg_instance = fcu_get_switch( $args_ref, "instance" );

    my $arg_mdi_port = fcu_get_switch( $args_ref, "mdi-port" );

    my $arg_s = fcu_get_switch($args_ref,"s");
    my $arg_save_gdb_script = fcu_get_switch($args_ref,"save-gdb-script");
    $arg_save_gdb_script = 1 if $arg_s; # "-s" is the same as "--save-gdb-script"

    my $arg_command = fcu_get_switch($args_ref,"command");  # gdb command filename

    my $arg_verbosity = fcu_get_switch($args_ref,"verbosity");
    my $arg_pagecache = fcu_get_switch($args_ref,"pagecache");

    my $arg_filename;

    if( fcu_get_switch($args_ref,"_argc") == 1 )
    {
        $arg_filename = fcu_get_switch($args_ref,"0");
    }
    else
    {
        die "### $my_name: exactly one filename required.\n";
    }

    # check consistency

    if ( $arg_filename )
    {
        # if the file is not already a .elf file...

        unless ( $arg_filename =~ /\.elf$/ )
        {
            # ...remove .srec from the end...

            $arg_filename =~ s/\.srec$//;

            # ...and add .elf to the end

            $arg_filename .= ".elf";
        }
    }
    else
    {
        die "### $my_name: either an srec filename or .elf filename must be provided\n";
    }

    unless ( -e "$arg_filename" )
    {
        die "### $my_name: $arg_filename does not exist\n";
    }

    #
    # current working directory
    #

    my $cwd = `pwd`;
    chop $cwd;
    $cwd =~ s/\/cygdrive\/(.)/$1:/;         # we need a DOS-style path
    $cwd =~ s/\/$//;                        # take the slash off the end

    my $relative = $cwd;                    # create a relative path to '/' (on the same drive)...
    $relative =~ s/^.:\///;                 # ...remove drive and slash from beginning
    $relative .= "/";                       # ...put a slash on the end
    $relative =~ s/.*?\//..\//g;            # ...and replace all dir names with '..'

    my $sopc_kit_nios2 = $ENV{SOPC_KIT_NIOS2};
    $sopc_kit_nios2 =~ s|\\|\/|g; # replace backslashes with forward slashes
    $sopc_kit_nios2 =~ s|^.:\/||; # remove the drive letter, colon and slash from the beginning

    #
    # the newlib source directories
    #
        
    my @lib_source_paths =
    (
        "$relative$sopc_kit_nios2/bin/nios2-gnutools/src/newlib/newlib/libc/ctype",
        "$relative$sopc_kit_nios2/bin/nios2-gnutools/src/newlib/newlib/libc/stdio",
        "$relative$sopc_kit_nios2/bin/nios2-gnutools/src/newlib/newlib/libc/stdlib",
        "$relative$sopc_kit_nios2/bin/nios2-gnutools/src/newlib/newlib/libc/string",
        "$relative$sopc_kit_nios2/bin/nios2-gnutools/src/newlib/newlib/libm/common",
        "$relative$sopc_kit_nios2/bin/nios2-gnutools/src/newlib/newlib/libm/math",
        "$relative$sopc_kit_nios2/bin/nios2-gnutools/src/newlib/newlib/libm/mathfp",
        "$relative$sopc_kit_nios2/bin/nios2-gnutools/src/newlib/newlib/libgloss",
        "$relative$sopc_kit_nios2/bin/nios2-gnutools/src/newlib/newlib/libgloss/nios2",
        "$relative$sopc_kit_nios2/bin/nios2-gnutools/src/newlib/newlib/libgloss/libnosys"
    );

    my $gdb_command_filename;

    if ( $arg_command )
    {
        $gdb_command_filename = $arg_command;
        $arg_save_gdb_script = 1;

        unless ( -e $gdb_command_filename )
        {
            die "### $my_name: $gdb_command_filename does not exist ($!)\n";
        }
    }
    else
    {
        $gdb_command_filename = $arg_filename;
        $gdb_command_filename =~ s/\.elf$//;
        $gdb_command_filename = $gdb_command_filename . "_setup.gdb";
        $gdb_command_filename =~ tr/\//_/;              # turn slashes to underscores
    
        #
        # Either tell the user about it,
        # or stash it in /tmp
        #

        if( $arg_save_gdb_script )
        {
            fcu_print_command( "Creating $gdb_command_filename" );
        }
        else
        {
            $gdb_command_filename = "/tmp/" . $gdb_command_filename;
        }

        #
        # create a (temporary) GDB command file
        #

        my $gdb_cmd_file_contents = generate_gdb_cmd_file_contents(
                                                $gdb_command_filename,
                                                $arg_filename,
                                                $arg_tcpport,
                                                @lib_source_paths );

        open TMP, ">$gdb_command_filename"
            or die "### $my_name: can't create $gdb_command_filename ($!)\n";

        print TMP $gdb_cmd_file_contents;

        close TMP
            or die "### $my_name: can't close $gdb_command_filename ($!)\n";
    }

    #
    # do we need to delete the user.tcl file?
    #

    if ( $arg_cli )
    {
        # if we don't do this, the Debug Console (CLI) and GDB will get very confused
        unlink "$ENV{sopc_kit_nios2}/bin/FS2/Bin/user.tcl";
    }

    #
    # start nios2-gdb-server
    #

    my $ngs_cmd;

    if ( $arg_cli )
    {
        # only nios2-gdb-server-fs2 supports the --console option
        $ngs_cmd = "nios2-gdb-server-fs2 --console";
        $ngs_cmd .= " --connect-reset=1" if $arg_reset ne " --connect-reset=0";
        
        if ( !$arg_reset ) 
        {
            # we need to stop the processor if not resetting SPR:145028
            my $ngs_stop_cmd = "nios2-gdb-server --stop"; 

            $ngs_stop_cmd .= " --cable=\"$arg_cable\""     if $arg_cable ne "";
            $ngs_stop_cmd .= " --device=$arg_device"       if $arg_device ne "";
            $ngs_stop_cmd .= " --instance=$arg_instance"   if $arg_instance ne "";

            fcu_print_command( "Pausing target system" );
            r_system ( "$ngs_stop_cmd"  ) == 0
                or die "### $my_name: can't pause target system\n";
        }

    }
    else
    {
        # otherwise (if --console isn't used) invoke nios2-gdb-server
        $ngs_cmd = "nios2-gdb-server";
        $ngs_cmd .= " --reset-target" if $arg_reset ne "";
    }

    $ngs_cmd .= " --tcpport=$arg_tcpport";
    $ngs_cmd .= " --cable=\"$arg_cable\""     if $arg_cable ne "";
    $ngs_cmd .= " --device=$arg_device"       if $arg_device ne "";
    $ngs_cmd .= " --instance=$arg_instance"   if $arg_instance ne "";
    $ngs_cmd .= " --mdi-port=$arg_mdi_port"   if $arg_mdi_port ne "";
    $ngs_cmd .= " --verbosity=$arg_verbosity" if $arg_verbosity ne "";
    $ngs_cmd .= " --pagecache=$arg_pagecache" if $arg_pagecache ne "";

    $ngs_cmd .= "&"; # run it in the background

    r_system( "$ngs_cmd" ) == 0
        or die "### $my_name: can't system nios2-gdb-server ($!)\n";

    #
    # and finally start nios2-elf-insight itself
    #

    my $gdb_cmd = "$my_debugger --command=$gdb_command_filename";

    fcu_print_command( "downloading $arg_filename" );

    r_system ( "$gdb_cmd" ) == 0
        or die "### $my_name: can't system $my_debugger ($!)\n";

    fcu_print_command( "finished" );

    unless( $arg_save_gdb_script )
    {
        unlink $gdb_command_filename;       # delete the temporary command file
    }
}



#
# usage info
sub usage
{
        print <<EOT;

Usage: $my_name [OPTIONS(s)] FILENAME

Open the GDB/Insight debugger.  A filename must be provided, either that of
an elf file or an srec file.

  OPTION                         DESCRIPTION
  --console/-c                   Show the FS2 CLI debug console
  --reset-target/-r              Reset the target SOPC system before use.
  --tcpport=<port>               The TCP port for nios2-gdb-server and
                                 nios2-gdb-insight to use (default is 2342)
  --cable=<JTAG cable name>      Have nios2-gdb-server use the indicated cable
  --device=<JTAG device number>  Have nios2-gdb-server use the indicated
                                 device
  --instance=<JTAG debug module node index>
                                 Have nios2-gdb-server use the indicated
                                 JTAG debug module node
  --mdi-port=<MDI port name>     Use the indicated MDI port (default is "sld")
  --save-gdb-script              Save a copy of the GDB script created in the
                                 current working directory (it is normally
                                 deleted when debugging is finished)
  --command=<GDB script name>    Use the indicated GDB script (possibly
                                 generated using -save-gdb-script previously)
                                 instead of the default

EOT
        exit;
}



# --------------------------------------------
# Minimal open main instructions

        main(@ARGV);

# end of file
