# Don't run fixproto.
STMP_FIXPROTO =

# Build libgcc using the multilib mechanism
LIBGCC = stmp-multilib
INSTALL_LIBGCC = install-multilib

# No special flags needed for libgcc.a
TARGET_LIBGCC2_CFLAGS =

# Don't build libgcc.a with debug info
LIBGCC2_DEBUG_CFLAGS =

# The VxWorks version of libgcc includes vxlib.c.  That file
# #includes <taskLib.h>.  In turn, <taskLib.h> #includes <regs.h>,
# which is a VxWorks system header file.  Unfortunately, because we
# compile libgcc with -I $(srcdir), the VxWorks <taskLib.h> header
# includes gcc/regs.h, rather than the VxWorks system header.
#
# This is a not, in theory, a VxWorks-specific problem; We would have
# the same problem on a GLIBC system if we had a GCC header named
# features.h. 
#
# When building libgcc, using the $(INCLUDES) causes that inclusion
# to get the GCC regs.h rather than the VxWorks regs.h.  That happens
# because the -I options in $(INCLUDES) take precendence over the
# -isystem in the VxWorks configuration specs.  We work around this
# problem in the VxWorks headers by using -idirafter instead of -I.
LIBGCC_INCLUDES = $(patsubst -I%,-idirafter %,$(INCLUDES))

# Extra libgcc2 module used by gthr-vxworks.h functions
LIB2FUNCS_EXTRA = $(srcdir)/config/vxlib.c

# Some runtime modules need these.  Can't set extra_headers in config.gcc
# because the paths are always made absolute to the cpu config dir.
EXTRA_HEADERS += $(srcdir)/gthr-vxworks.h gthr-default.h

# This ensures that the correct target headers are used; some
# VxWorks system headers have names that collide with GCC's
# internal (host) headers, e.g. regs.h.
# FIXME: May not be necessary anymore.
LIBGCC2_INCLUDES="-I$(SYSTEM_HEADER_DIR)"

# Both the kernel and RTP headers provide limits.h.
LIMITS_H_TEST = true

EXTRA_MULTILIB_PARTS = 

vxworks.o: $(srcdir)/config/vxworks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
	$(TARGET_H) toplev.h output.h $(TARGET_H) $(TREE_H)
	$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<
